{"version":3,"sources":["webpack:///webpack/bootstrap","webpack:///./src/index.js"],"names":[],"mappings":";AAAA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;;AAGA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,kDAA0C,gCAAgC;AAC1E;AACA;;AAEA;AACA;AACA;AACA,gEAAwD,kBAAkB;AAC1E;AACA,yDAAiD,cAAc;AAC/D;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iDAAyC,iCAAiC;AAC1E,wHAAgH,mBAAmB,EAAE;AACrI;AACA;;AAEA;AACA;AACA;AACA,mCAA2B,0BAA0B,EAAE;AACvD,yCAAiC,eAAe;AAChD;AACA;AACA;;AAEA;AACA,8DAAsD,+DAA+D;;AAErH;AACA;;;AAGA;AACA;;;;;;;;;;;;AClFA;AACA;;AAEA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA,gDAAgD;;AAEhD;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B;;AAE/B;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,gGAAgG,wBAAwB;AACxH,iGAAiG,wBAAwB;AACzH,gFAAgF,wBAAwB;AACxG,uFAAuF,wBAAwB;AAC/G;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;;AAEA,qDAAqD;AACrD,sCAAsC;AACtC;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;;AAEA,iBAAiB,2BAA2B;AAC5C,iBAAiB,2BAA2B;;AAE5C;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;;AAEA,CAAC","file":"main.js","sourcesContent":[" \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = \"./src/index.js\");\n","const width = 500;\nconst height = 500;\n\nconst N = 1 << 0;\nconst S = 1 << 1;\nconst W = 1 << 2;\nconst E = 1 << 3;\n\n\nconst cellSize = 4;\nconst cellSpacing = 4;\nconst cellWidth = Math.floor((width - cellSpacing) / (cellSize + cellSpacing));\nconst cellHeight = Math.floor((height - cellSpacing) / (cellSize + cellSpacing));\nconst cells = new Array(cellWidth * cellHeight); // each cellâ€™s edge bits\n\nfunction exploreFrontier(ctx, frontier) {\n\n  let edge;\n\n  if ((edge = popRandom(frontier)) == null) return true;\n\n  let i0 = edge.index;\n  let d0 = edge.direction;\n  let i1 = i0 + (d0 === N ? -cellWidth : d0 === S ? cellWidth : d0 === W ? -1 : +1);\n  let x0 = i0 % cellWidth;\n  let y0 = i0 / cellWidth | 0;\n  let x1;\n  let y1;\n  let d1;\n  let open = cells[i1] == null; // opposite not yet part of the maze\n\n  ctx.fillStyle = open ? \"white\" : \"black\";\n\n  if (d0 === N) fillSouth(i1, ctx), x1 = x0, y1 = y0 - 1, d1 = S;\n  else if (d0 === S) fillSouth(i0, ctx), x1 = x0, y1 = y0 + 1, d1 = N;\n  else if (d0 === W) fillEast(i1, ctx), x1 = x0 - 1, y1 = y0, d1 = E;\n  else fillEast(i0, ctx), x1 = x0 + 1, y1 = y0, d1 = W;\n\n  if (open) {\n    fillCell(i1, ctx);\n    cells[i0] |= d0, cells[i1] |= d1;\n    ctx.fillStyle = \"magenta\";\n    if (y1 > 0 && cells[i1 - cellWidth] == null) fillSouth(i1 - cellWidth, ctx), frontier.push({index: i1, direction: N});\n    if (y1 < cellHeight - 1 && cells[i1 + cellWidth] == null) fillSouth(i1, ctx), frontier.push({index: i1, direction: S});\n    if (x1 > 0 && cells[i1 - 1] == null) fillEast(i1 - 1 , ctx), frontier.push({index: i1, direction: W});\n    if (x1 < cellWidth - 1 && cells[i1 + 1] == null) fillEast(i1, ctx), frontier.push({index: i1, direction: E});\n  }\n}\n\nfunction fillCell(index, ctx) {\n  let i = index % cellWidth\n  let j = index / cellWidth | 0;\n  ctx.fillRect(i * cellSize + (i + 1) * cellSpacing, j * cellSize + (j + 1) * cellSpacing, cellSize, cellSize);\n}\n\nfunction fillEast(index, ctx) {\n  let i = index % cellWidth;\n  let j = index / cellWidth | 0;\n  ctx.fillRect((i + 1) * (cellSize + cellSpacing), j * cellSize + (j + 1) * cellSpacing, cellSize, cellSize);\n}\n\nfunction fillSouth(index, ctx) {\n  var i = index % cellWidth, j = index / cellWidth | 0;\n  ctx.fillRect(i * cellSize + (i + 1) * cellSpacing, (j + 1) * (cellSize + cellSpacing), cellSize, cellSize);\n}\n\nfunction popRandom(array) {\n  if (!array.length) return;\n  let n = array.length;\n  let i = Math.random() * n | 0;\n  [array[i], array[n - 1]] = [array[n - 1], array[i]];\n  return array.pop();\n}\n\n\ndocument.addEventListener(\"DOMContentLoaded\", function(){\n\n  const canvas = document.getElementById(\"myCanvas\"); //esta en el body y esta dentro del dom\n  const ctx = canvas.getContext(\"2d\"); //devuelve objeto que se puede pintar\n  const frontier = [];\n\n  console.log(    Math.round((width - cellWidth * cellSize - (cellWidth + 1) * cellSpacing) / 2),\n      Math.round((height - cellHeight * cellSize - (cellHeight + 1) * cellSpacing) / 2)\n);\n  ctx.translate(\n    Math.round((width - cellWidth * cellSize - (cellWidth + 1) * cellSpacing) / 2),\n    Math.round((height - cellHeight * cellSize - (cellHeight + 1) * cellSpacing) / 2)\n  );\n\n  ctx.fillStyle = \"red\";\n\n  const start = (cellHeight - 1) * cellWidth;\n  cells[start] = 0;\n\n  fillCell(start, ctx);\n\n  frontier.push({index: start, direction: N});\n  frontier.push({index: start, direction: E});\n\n  setInterval(function() {\n    let done;\n    let k = 0;\n    while (++k < 50 && !(done = exploreFrontier(ctx, frontier)));\n    console.log('foo')\n    return done;\n  }, 100);\n//\n//\n// d3.select(self.frameElement).style(\"height\", height + \"px\");\n\n});\n"],"sourceRoot":""}